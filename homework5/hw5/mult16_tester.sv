

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC
#(parameter    HEX_0 = 7'b100_0000, parameter    HEX_1 = 7'b111_1001,    parameter    HEX_2 = 7'b010_0100, 
  parameter    HEX_3 = 7'b011_0000, parameter    HEX_4 = 7'b001_1001,    parameter    HEX_5 = 7'b001_0010, 
  parameter    HEX_6 = 7'b000_0010, parameter    HEX_7 = 7'b111_1000,    parameter    HEX_8 = 7'b000_0000, 
  parameter    HEX_9 = 7'b001_0000, parameter    HEX_A = 7'b000_1000,    parameter    HEX_B = 7'b000_1011,
  parameter    HEX_C = 7'b100_0110, parameter    HEX_D = 7'b010_0011,    parameter    HEX_E = 7'b100_1110, 
  parameter    HEX_F = 7'b000_1111, parameter    HEX_I = 7'b100_0000,    parameter    HEX_S = 7'b100_1110, 
  parameter    HEX_P = 7'b000_1111, parameter    IDLE = 3'd0,            parameter    START = 3'd1, 
  parameter    SET_INPUTS = 3'd2  , parameter    TEST_PROCESSING = 3'd3, parameter    TEST_PASSED = 3'd4, 
  parameter    TEST_FAILED = 3'd5 , parameter    UPDATE_INPUTS = 3'd6,   parameter    TEST_COMPLETE = 3'd7)
(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

   logic 			clock;
	logic 			reset_n;
	logic 			begin_test;
	logic 			inject_error;
	logic [1:0] 	reset_int;
	logic [2:0] 	state;
	logic [15:0] 	a;
	logic [15:0] 	b;
	logic [6:0]		segA1;
	logic [6:0]		segA2;
	logic [6:0]		segB1;
	logic [6:0]		segB2;


//=======================================================
//  Structural coding
//=======================================================


// button debouncing and edge detection
	// Define the first flip-flop stage
	always_ff @(posedge CLOCK_50)
		reset_int[0] <= !KEY[0];

	// Define the second flip-flop stage
	always_ff @(posedge CLOCK_50)
		reset_int[1] <= reset_int[0];

	// Define the output flip-flop stage
	always_ff @(posedge CLOCK_50)
		reset_n <= reset_int[1];
		
	button start_debounce(clock, KEY[1], begin_test);
	button error_debounce(clock, KEY[2], inject_error);
	
	// clock divider to generate 1Hz clock
	always_ff @(posedge CLOCK_50 or negedge reset_n) begin
      if (!reset_n) begin
          clock <= 0;
      end else if (clock) begin
          clock <= 0;
      end else begin
          clock <= 1;
      end
   end
    
   // status module to output the status register to the HEX displays
   status status_inst(
       .clock(clock),
       .reset_n(reset_n),
       .begin_test(begin_test),
       .inject_error(inject_error),
       .state(state),
       .a(a),
       .b(b)
   );
	
	
	assign segA1 = (a[15:12] == 4'd0)  ? HEX_0 :
						(a[15:12] == 4'd1)  ? HEX_1 :
						(a[15:12] == 4'd2)  ? HEX_2 :
						(a[15:12] == 4'd3)  ? HEX_3 :
						(a[15:12] == 4'd4)  ? HEX_4 :
						(a[15:12] == 4'd5)  ? HEX_5 :
						(a[15:12] == 4'd6)  ? HEX_6 :
						(a[15:12] == 4'd7)  ? HEX_7 :
						(a[15:12] == 4'd8)  ? HEX_8 :
						(a[15:12] == 4'd9)  ? HEX_9 :
						(a[15:12] == 4'd10) ? HEX_A :
						(a[15:12] == 4'd11) ? HEX_B :
						(a[15:12] == 4'd12) ? HEX_C :
						(a[15:12] == 4'd13) ? HEX_D :
						(a[15:12] == 4'd14) ? HEX_E :
						(a[15:12] == 4'd15) ? HEX_F :
						HEX_E;
						
	assign segA2 = (a[11:8]  == 4'd0)  ? HEX_0 :
						(a[11:8]  == 4'd1)  ? HEX_1 :
						(a[11:8]  == 4'd2)  ? HEX_2 :
						(a[11:8]  == 4'd3)  ? HEX_3 :
						(a[11:8]  == 4'd4)  ? HEX_4 :
						(a[11:8]  == 4'd5)  ? HEX_5 :
						(a[11:8]  == 4'd6)  ? HEX_6 :
						(a[11:8]  == 4'd7)  ? HEX_7 :
						(a[11:8]  == 4'd8)  ? HEX_8 :
						(a[11:8]  == 4'd9)  ? HEX_9 :
						(a[11:8]  == 4'd10) ? HEX_A :
						(a[11:8]  == 4'd11) ? HEX_B :
						(a[11:8]  == 4'd12) ? HEX_C :
						(a[11:8]  == 4'd13) ? HEX_D :
						(a[11:8]  == 4'd14) ? HEX_E :
						(a[11:8]  == 4'd15) ? HEX_F :
						HEX_E;
						
	assign segB1 = (b[15:12] == 4'd0)  ? HEX_0 :
						(b[15:12] == 4'd1)  ? HEX_1 :
						(b[15:12] == 4'd2)  ? HEX_2 :
						(b[15:12] == 4'd3)  ? HEX_3 :
						(b[15:12] == 4'd4)  ? HEX_4 :
						(b[15:12] == 4'd5)  ? HEX_5 :
						(b[15:12] == 4'd6)  ? HEX_6 :
						(b[15:12] == 4'd7)  ? HEX_7 :
						(b[15:12] == 4'd8)  ? HEX_8 :
						(b[15:12] == 4'd9)  ? HEX_9 :
						(b[15:12] == 4'd10) ? HEX_A :
						(b[15:12] == 4'd11) ? HEX_B :
						(b[15:12] == 4'd12) ? HEX_C :
						(b[15:12] == 4'd13) ? HEX_D :
						(b[15:12] == 4'd14) ? HEX_E :
						(b[15:12] == 4'd15) ? HEX_F :
						HEX_E;
						
	assign segB2 = (b[11:8]  == 4'd0)  ? HEX_0 :
						(b[11:8]  == 4'd1)  ? HEX_1 :
						(b[11:8]  == 4'd2)  ? HEX_2 :
						(b[11:8]  == 4'd3)  ? HEX_3 :
						(b[11:8]  == 4'd4)  ? HEX_4 :
						(b[11:8]  == 4'd5)  ? HEX_5 :
						(b[11:8]  == 4'd6)  ? HEX_6 :
						(b[11:8]  == 4'd7)  ? HEX_7 :
						(b[11:8]  == 4'd8)  ? HEX_8 :
						(b[11:8]  == 4'd9)  ? HEX_9 :
						(b[11:8]  == 4'd10) ? HEX_A :
						(b[11:8]  == 4'd11) ? HEX_B :
						(b[11:8]  == 4'd12) ? HEX_C :
						(b[11:8]  == 4'd13) ? HEX_D :
						(b[11:8]  == 4'd14) ? HEX_E :
						(b[11:8]  == 4'd15) ? HEX_F :
						HEX_E;

   // HEX display update
   always_comb begin
		 case (state)
			   IDLE: begin
               HEX5 = HEX_I;
               HEX4 = HEX_I;
               HEX3 = HEX_I;
               HEX2 = HEX_I;
               HEX1 = HEX_I;
               HEX0 = HEX_I;
            end

            START: begin
               HEX5 = HEX_S;
               HEX4 = HEX_S;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            TEST_PROCESSING: begin
               HEX5 = HEX_P;
               HEX4 = HEX_P;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            UPDATE_INPUTS: begin
               HEX5 = HEX_P;
               HEX4 = HEX_P;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end
				
            TEST_FAILED: begin
               HEX5 = HEX_E;
               HEX4 = HEX_E;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            TEST_COMPLETE: begin
               HEX5 = HEX_F;
               HEX4 = HEX_F;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            default: begin
               HEX5 = HEX_E;
               HEX4 = HEX_E;
               HEX3 = HEX_E;
               HEX2 = HEX_E;
               HEX1 = HEX_E;
               HEX0 = HEX_E;
            end
       endcase
   end
endmodule



module mult16_tester 
#(parameter    HEX_0 = 7'b100_0000, parameter    HEX_1 = 7'b111_1001,    parameter    HEX_2 = 7'b010_0100, 
  parameter    HEX_3 = 7'b011_0000, parameter    HEX_4 = 7'b001_1001,    parameter    HEX_5 = 7'b001_0010, 
  parameter    HEX_6 = 7'b000_0010, parameter    HEX_7 = 7'b111_1000,    parameter    HEX_8 = 7'b000_0000, 
  parameter    HEX_9 = 7'b001_0000, parameter    HEX_A = 7'b000_1000,    parameter    HEX_B = 7'b000_1011,
  parameter    HEX_C = 7'b100_0110, parameter    HEX_D = 7'b010_0011,    parameter    HEX_E = 7'b100_1110, 
  parameter    HEX_F = 7'b000_1111, parameter    HEX_I = 7'b100_0000,    parameter    HEX_S = 7'b100_1110, 
  parameter    HEX_P = 7'b000_1111, parameter    IDLE = 3'd0,            parameter    START = 3'd1, 
  parameter    SET_INPUTS = 3'd2  , parameter    TEST_PROCESSING = 3'd3, parameter    TEST_PASSED = 3'd4, 
  parameter    TEST_FAILED = 3'd5 , parameter    UPDATE_INPUTS = 3'd6,   parameter    TEST_COMPLETE = 3'd7)
(
    input  logic         CLOCK_50,
    input  logic  [2:0]  KEY,
    output logic  [6:0]  HEX5, 
    output logic  [6:0]  HEX4,
    output logic  [6:0]  HEX3, 
    output logic  [6:0]  HEX2, 
    output logic  [6:0]  HEX1, 
    output logic  [6:0]  HEX0
);

   logic 			clock;
	logic 			reset_n;
	logic 			begin_test;
	logic 			inject_error;
	logic [1:0] 	reset_int;
	logic [2:0] 	state;
	logic [15:0] 	a;
	logic [15:0] 	b;
	logic [6:0]		segA1;
	logic [6:0]		segA2;
	logic [6:0]		segB1;
	logic [6:0]		segB2;
    
   // button debouncing and edge detection
	// Define the first flip-flop stage
	always_ff @(posedge CLOCK_50)
		reset_int[0] <= KEY[0];

	// Define the second flip-flop stage
	always_ff @(posedge CLOCK_50)
		reset_int[1] <= reset_int[0];

	// Define the output flip-flop stage
	always_ff @(posedge CLOCK_50)
		reset_n <= reset_int[1];
		
	button start_debounce(clock, KEY[1], begin_test);
	button error_debounce(clock, KEY[2], inject_error);
	
	// clock divider to generate 1Hz clock
	always_ff @(posedge CLOCK_50 or negedge reset_n) begin
      if (!reset_n) begin
          clock <= 0;
      end else if (clock) begin
          clock <= 0;
      end else begin
          clock <= 1;
      end
   end
    
   // status module to output the status register to the HEX displays
   status status_inst(
       .clock(clock),
       .reset_n(reset_n),
       .begin_test(begin_test),
       .inject_error(inject_error),
       .state(state),
       .a(a),
       .b(b)
   );
	
	
	assign segA1 = (a[15:12] == 4'd0)  ? HEX_0 :
						(a[15:12] == 4'd1)  ? HEX_1 :
						(a[15:12] == 4'd2)  ? HEX_2 :
						(a[15:12] == 4'd3)  ? HEX_3 :
						(a[15:12] == 4'd4)  ? HEX_4 :
						(a[15:12] == 4'd5)  ? HEX_5 :
						(a[15:12] == 4'd6)  ? HEX_6 :
						(a[15:12] == 4'd7)  ? HEX_7 :
						(a[15:12] == 4'd8)  ? HEX_8 :
						(a[15:12] == 4'd9)  ? HEX_9 :
						(a[15:12] == 4'd10) ? HEX_A :
						(a[15:12] == 4'd11) ? HEX_B :
						(a[15:12] == 4'd12) ? HEX_C :
						(a[15:12] == 4'd13) ? HEX_D :
						(a[15:12] == 4'd14) ? HEX_E :
						(a[15:12] == 4'd15) ? HEX_F :
						HEX_E;
						
	assign segA2 = (a[11:8]  == 4'd0)  ? HEX_0 :
						(a[11:8]  == 4'd1)  ? HEX_1 :
						(a[11:8]  == 4'd2)  ? HEX_2 :
						(a[11:8]  == 4'd3)  ? HEX_3 :
						(a[11:8]  == 4'd4)  ? HEX_4 :
						(a[11:8]  == 4'd5)  ? HEX_5 :
						(a[11:8]  == 4'd6)  ? HEX_6 :
						(a[11:8]  == 4'd7)  ? HEX_7 :
						(a[11:8]  == 4'd8)  ? HEX_8 :
						(a[11:8]  == 4'd9)  ? HEX_9 :
						(a[11:8]  == 4'd10) ? HEX_A :
						(a[11:8]  == 4'd11) ? HEX_B :
						(a[11:8]  == 4'd12) ? HEX_C :
						(a[11:8]  == 4'd13) ? HEX_D :
						(a[11:8]  == 4'd14) ? HEX_E :
						(a[11:8]  == 4'd15) ? HEX_F :
						HEX_E;
						
	assign segB1 = (b[15:12] == 4'd0)  ? HEX_0 :
						(b[15:12] == 4'd1)  ? HEX_1 :
						(b[15:12] == 4'd2)  ? HEX_2 :
						(b[15:12] == 4'd3)  ? HEX_3 :
						(b[15:12] == 4'd4)  ? HEX_4 :
						(b[15:12] == 4'd5)  ? HEX_5 :
						(b[15:12] == 4'd6)  ? HEX_6 :
						(b[15:12] == 4'd7)  ? HEX_7 :
						(b[15:12] == 4'd8)  ? HEX_8 :
						(b[15:12] == 4'd9)  ? HEX_9 :
						(b[15:12] == 4'd10) ? HEX_A :
						(b[15:12] == 4'd11) ? HEX_B :
						(b[15:12] == 4'd12) ? HEX_C :
						(b[15:12] == 4'd13) ? HEX_D :
						(b[15:12] == 4'd14) ? HEX_E :
						(b[15:12] == 4'd15) ? HEX_F :
						HEX_E;
						
	assign segB2 = (b[11:8]  == 4'd0)  ? HEX_0 :
						(b[11:8]  == 4'd1)  ? HEX_1 :
						(b[11:8]  == 4'd2)  ? HEX_2 :
						(b[11:8]  == 4'd3)  ? HEX_3 :
						(b[11:8]  == 4'd4)  ? HEX_4 :
						(b[11:8]  == 4'd5)  ? HEX_5 :
						(b[11:8]  == 4'd6)  ? HEX_6 :
						(b[11:8]  == 4'd7)  ? HEX_7 :
						(b[11:8]  == 4'd8)  ? HEX_8 :
						(b[11:8]  == 4'd9)  ? HEX_9 :
						(b[11:8]  == 4'd10) ? HEX_A :
						(b[11:8]  == 4'd11) ? HEX_B :
						(b[11:8]  == 4'd12) ? HEX_C :
						(b[11:8]  == 4'd13) ? HEX_D :
						(b[11:8]  == 4'd14) ? HEX_E :
						(b[11:8]  == 4'd15) ? HEX_F :
						HEX_E;

   // HEX display update
   always_comb begin
		 case (state)
			   IDLE: begin
               HEX5 = HEX_I;
               HEX4 = HEX_I;
               HEX3 = HEX_I;
               HEX2 = HEX_I;
               HEX1 = HEX_I;
               HEX0 = HEX_I;
            end

            START: begin
               HEX5 = HEX_S;
               HEX4 = HEX_S;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            TEST_PROCESSING: begin
               HEX5 = HEX_P;
               HEX4 = HEX_P;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            UPDATE_INPUTS: begin
               HEX5 = HEX_P;
               HEX4 = HEX_P;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end
				
            TEST_FAILED: begin
               HEX5 = HEX_E;
               HEX4 = HEX_E;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            TEST_COMPLETE: begin
               HEX5 = HEX_F;
               HEX4 = HEX_F;
               HEX3 = segA1;
               HEX2 = segA2;
               HEX1 = segB1;
               HEX0 = segB2;
            end

            default: begin
               HEX5 = HEX_E;
               HEX4 = HEX_E;
               HEX3 = HEX_E;
               HEX2 = HEX_E;
               HEX1 = HEX_E;
               HEX0 = HEX_E;
            end
       endcase
   end
endmodule


module mult16_tester_tb();
	// Inputs
	logic         clock;
	logic  [2:0]  KEY;
	// Outputs
   logic  [6:0]  HEX5, HEX4, HEX3, HEX2, HEX1, HEX0;
	
	
	// Instantiate the Unit Under Test (UUT)
	mult16_tester m16_tester(clock, KEY, HEX5, HEX4, HEX3, HEX2, HEX1, HEX0);
	
	parameter clk_period = 10;
	// Reset generation
	initial begin
		 clock = 0;
		 KEY = 0;
	end	
	// Clock generation
	always #(clk_period)  clock = ~clock;
	
	initial begin
		 // Wait 100 ns for global reset to finish
		 #1000;
		 // Add stimulus here
		 KEY = 3'd3; // Press the start button
		 #100;
		 KEY = 3'd0; // Press the start button
		 #200000;
		 $stop;
	end

endmodule